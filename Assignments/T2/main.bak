#lang play

#|
<expr> ::= <num>
         | <bool>
         | <id>
         | <string>
         | {if <expr> <expr> <expr>}
         | {fun {<id>*}}  <expr>}
         | {<expr> <expr>*}
         | {local {<def>*} <expr>}
         | {match <expr> <case>+}
<case> ::= {'case <pattern> '=> <expr>}
<pattern> ::= <num>
         | <bool>
         | <string>
         | <id>
         | (<constr-id> <attr-id>*)
<def>  ::= {define <id> <expr>}
         | {datatype <typename> <type-constructor>*}}
<type-constructor> ::= {<id> <member>*}
<constr-id> :: = <id>
<attr-id> :: = <id>
<typename> :: = <id>
<member>   :: = <id>
|#
; expresiones
(deftype Expr
  (num n)
  (bool b)
  (str s)
  (ifc c t f)
  (id s)
  (app fun-expr arg-expr-list)
  (prim-app name args)   ; aplicación de primitivas
  (fun id body)
  (lcal defs body)
  (mtch val cases))

; definiciones
(deftype Def
  (dfine name val-expr) ; define
  (datatype name variants)) ; datatype

; variantes
(deftype Variant
  (variant name params))

; estructuras de datos
(deftype Struct
  (structV name variant values))

; caso en pattern matching
(deftype Case
  (cse pattern body))

; patrón
(deftype Pattern
  (idP id) ; identificador
  (litP l) ; valor literal
  (constrP ctr patterns)) ; constructor y sub-patrones

;; parse :: s-expr -> Expr
(define(parse s-expr)
  (match s-expr
    [(? number?) (num s-expr)]
    [(? boolean?) (bool s-expr)]
    [(? string?) (str s-expr)]
    [(? symbol?) (id s-expr)]
    [(list 'list s-exprs ...) (parse-list s-exprs)] ; Syntactic sugar
    [(list 'if c t f) (ifc (parse c) (parse t) (parse f))]
    [(list 'fun xs b) (fun xs (parse b))]
    [(list 'with (list (list x e) ...) b)
     (app (fun x (parse b)) (map parse e))]
    [(list 'local defs body)
     (lcal (map parse-def defs) (parse body))]
    [(list 'match val-expr cases ...) ; note the elipsis to match n elements
     (mtch (parse val-expr) (map parse-case cases))] ; cases is a list
    [(list f args ...) ; same here
     (if (assq f *primitives*)
         (prim-app f (map parse args)) ; args is a list
         (app (parse f) (map parse args)))]))

; parse-list :: s-expr -> List
(define (parse-list l)
  (match l
    [(list first rest ...)
     (app (id 'Cons) (list (parse first) (parse-list rest)))]
    [(list) (app (id 'Empty) (list))]))

; parse-def :: s-expr -> Def
(define(parse-def s-expr)
  (match s-expr
    [(list 'define id val-expr) (dfine id (parse val-expr))]
    [(list 'datatype name variants ...) (datatype name (map parse-variant
                                                            variants))]))

; parse-variant :: sexpr -> Variant
(define(parse-variant v)
  (match v
    [(list name params ...) (variant name params)]))

; parse-case :: sexpr -> Case
(define(parse-case c)
  (match c
    [(list 'case pattern => body) (cse (parse-pattern pattern) (parse body))]))

; parse-pattern :: sexpr -> Pattern
(define(parse-pattern p)
  (match p
    [(? symbol?)  (idP p)]
    [(? number?)  (litP (num p))]
    [(? boolean?) (litP (bool p))]
    [(? string?)  (litP (str p))]
    [(list 'list elements ...) (parse-pattern-list elements)]
    [(list ctr patterns ...) (constrP (first p) (map parse-pattern patterns))]))

; parse-pattern-list : sexpr -> Pattern
; This function extends the parse-pattern in order to allow the list
; structure as a pattern.
(define (parse-pattern-list l)
  (match l
    [(list first rest ...)
     (constrP 'Cons (list (parse-pattern first) (parse-pattern-list rest)))]
    [(list) (constrP 'Empty (list))]))

; Values of the lenguage.
; We use cache to implement call-by-need 
(deftype Val
  (closureV arg body env)
  (exprV expr env cache))

;; interp :: Expr Env -> number/boolean/procedure/Struct
; We are going to asume that the values of the lenguage do not strictly require
; structures such as boolV or numV.
; Even if we do not use a structure, we have to use strict to check the value
; returned by the interpreter.
(define(interp expr env)
  (match expr
    ; literals
    [(num n) n]
    [(bool b) b]
    [(str s) s]
    ; conditional
    [(ifc c t f)
     (if (strict (interp c env))
         (strict (interp t env))
         (strict (interp f env)))]
    ; identifier
    [(id x) (env-lookup x env)]
    ; function -> the body of the function is the λ itself
    [(fun ids body)
     (λ (arg-vals fenv) ; We save the environment of the function
       (interp body
               (extend-env (map transform-id ids)
                           ; We have to check lazyness in the ids!
                           (map (λ (x id) (interp-lazy x id fenv))
                                arg-vals ids)
                           env)))]
    ; application -> we just interp the fun-expr to get the λ function
    [(app fun-expr arg-expr-list)
     ; interpreting a function gives us the λ definition
     ((interp fun-expr env) arg-expr-list env)]
    ; primitive application
    [(prim-app prim arg-expr-list)
     (apply (cadr (assq prim *primitives*))
            (map (λ (a) (interp a env)) arg-expr-list))]
    ; local definitions
    [(lcal defs body)
     (def new-env (extend-env '() '() env))
     (for-each (λ (d) (interp-def d new-env)) defs)
     (strict (interp body new-env))] ; strict it
    ; pattern matching
    [(mtch expr cases)
     (def value-matched (interp expr env))
     (def (cons alist body) (find-first-matching-case value-matched cases))
     (strict (interp body (extend-env (map car alist) (map cdr alist) env)))])) 

; strict : Val (exprV/closureV/numV/boolV) -> Val (closureV/numV/boolV)
(define (strict val)
  (match val
    [(exprV expr env cache)
     (if (unbox cache)
         (begin
           ; (printf "using cached value ~v~n" (unbox cache)) 
           (unbox cache))
         (let ([inval (strict-stream (interp expr env))])
           ;(printf "Forcing exprV to ~v~n" inval)
           (set-box! cache inval)
           inval))]
    ; We add the structV case, which returns the same struct but with
    ; the values maped (for structures with 2 or more arguments)
    [(structV name variant val) (structV name variant (map strict val))]
    [_ val]))

; stric-stream : Val (exprV/closureV/numV/boolV) -> Val (closureV/numV/boolV)
; If we are in a stream, we only have to use the strict once.
(define (strict-stream val)
  (match val
    ; If we are in a stream, the expr will only use recursion once!
    ; Therefore, the (exprV) case no longer applies.
    [(structV name variant val) (structV name variant (map strict val))]
    [_ val]))

; transform-id :: sym/Cons -> sym
; returns the symbol of some id. If it comes with the flag "lazy", it returns
; the id without it.
(define (transform-id id)
  (match id
    [(list 'lazy x) x]
    [_ id]))

; interp-lazy :: Expr sym -> Expr
; Determines if some variable must be treated using call-by-need or not.
(define (interp-lazy fun-arg id env)
  (match id
    [(list 'lazy x) (exprV fun-arg env (box #f))]
    [_ (strict (interp fun-arg env))]))

; interp-def :: Def Env -> Void
(define(interp-def d env)
  (match d
    [(dfine id val-expr)
     (update-env! id (interp val-expr env) env)]
    [(datatype name variants)
     ;; extend environment with new definitions corresponding to the datatype
     (interp-datatype name env)
     (for-each (λ (v) (interp-variant name v env)) variants)]))

; interp-datatype :: String Env -> Void
(define(interp-datatype name env)
  ; datatype predicate, eg. Nat?
  (update-env! (string->symbol (string-append (symbol->string name) "?"))
               ; We now have to interp the id of the argument given
               (λ (v . fenv) ; Receiving a element of the env.
                 (symbol=? (structV-name (interp (first v) env))
                           name))
               env))

; interp-variant :: String String Env -> Void
(define(interp-variant name var env)
  ;; name and params of the variant or dataconstructor
  (def varname (variant-name var))
  (def varparams (variant-params var)) ; We need now the params of the variant
  ;; variant data constructor, eg. Zero, Succ
  (update-env! varname
               (λ (args fenv) ; given the arguments and the environment of the fun.
                 (structV name ; We create the structure, but with the values maped
                          varname
                          (map (λ (a lazy) (interp-lazy a lazy fenv)) ; lazy checker!
                               args
                               varparams)))
               env)
  ;; variant predicate, eg. Zero?, Succ?
  (update-env! (string->symbol (string-append (symbol->string varname) "?"))
               (λ (v . fenv) ; Receiving a element of the env.
                 (symbol=? (structV-variant (interp (first v) env))
                           varname))
               env))

;;;;; pattern matcher
(define(find-first-matching-case value cases)
  (match cases
    [(list) #f]
    [(cons (cse pattern body) cs)
     (let [(r (match-pattern-with-value pattern value))]
       (if (foldl (λ (x y)(and x y)) #t r)
           (cons r body)
           (find-first-matching-case value cs)))]))

(define(match-pattern-with-value pattern value)
  (match/values (values pattern value)
                [((idP i) v) (list (cons i v))]
                [((litP (bool v)) b)
                 (if (equal? v b) (list) (list #f))]
                [((litP (num v)) n)
                 (if (equal? v n) (list) (list #f))]
                [((constrP ctr patterns) (structV _ ctr-name str-values))
                 (if (symbol=? ctr ctr-name)
                     (apply append (map match-pattern-with-value
                                        patterns str-values))
                     (list #f))]
                [(x y) (error "Match failure")]))

; list data structure definition
(def list-struct '{datatype List
                            {Empty}
                            {Cons a b}})

; length :: List -> num
; function that receives a list and returns the length of it, but written
; in MiniScheme+ syntax.
(def length-function
  '{define length
     {fun {l}
          {match l
            {case {Cons a b} => {+ 1 {length b}}}
            {case {Empty} => 0}}}})

;; run :: s-expr -> number/boolean/procedura/struct
(define (run prog [flag ""])
  (begin
    ; We define the result given by the interp, using the list-struct def.
    (def given
      (interp (parse (list 'local (list list-struct length-function) prog))
              (mtEnv)))
    (match flag
      ["" given] ; No flag -> We simply return
      ["pp" (pretty-printing-list given)] ; pp flag, we use lists definition
      ["ppwu" (pretty-printing given)]))) ; ppwu, we use structures (no lists)

#|-----------------------------
Environment abstract data type
empty-env   :: Env
env-lookup  :: Sym Env -> Val
extend-env  :: List[Sym] List[Val] Env -> Env
update-env! :: Sym Val Env -> Void
|#
(deftype Env
  (mtEnv)
  (aEnv bindings rest)) ; bindings is a list of pairs (id . val)

(def empty-env  (mtEnv))

(define(env-lookup id env)
  (match env
    [(mtEnv) (error 'env-lookup "no binding for identifier: ~a" id)]
    [(aEnv bindings rest)
     (def binding (assoc id bindings))
     (if binding
         (cdr binding)
         (env-lookup id rest))]))

(define (extend-env ids vals env)
  (aEnv (map cons ids vals) ; zip to get list of pairs (id . val)
        env))

;; imperative update of env, adding/overriding the binding for id.
(define(update-env! id val env)
  (set-aEnv-bindings! env (cons (cons id val) (aEnv-bindings env))))

;;;;;;;

;;; primitives
; http://pleiad.cl/teaching/primitivas
(define *primitives*
  `((+       ,(lambda args (apply + args)))
    (-       ,(lambda args (apply - args)))
    (*       ,(lambda args (apply * args)))
    (%       ,(lambda args (apply modulo args)))
    (odd?    ,(lambda args (apply odd? args)))
    (even?   ,(lambda args (apply even? args)))
    (/       ,(lambda args (if (equal? (second args) 0)
                               (error "division by zero")
                               (apply / args))))
    (=       ,(lambda args (apply = args)))
    (<       ,(lambda args (apply < args)))
    (<=      ,(lambda args (apply <= args)))
    (>       ,(lambda args (apply > args)))
    (>=      ,(lambda args (apply >= args)))
    (zero?   ,(lambda args (apply zero? args)))
    (not     ,(lambda args (apply not args)))
    (and     ,(lambda args (apply (lambda (x y) (and x y)) args)))
    (or      ,(lambda args (apply (lambda (x y) (or x y)) args)))))

; to-str : number/boolean/id/string -> string
; returns an object as a string
(define (to-str obj)
  (match obj
    [(? number?)(string-append (number->string obj))]
    [(? symbol?)(string-append (symbol->string obj))]
    [(? boolean?)(string-append ((λ (b) (if b "#t" "#f")) obj))]
    [(? string?)(string-append obj)]))

; pretty-printing :: number/boolean/procedure/Struct -> string
; this function receives a data structure and returns the same structure
; but with a better visual representation.
(define (pretty-printing sV)
  (match sV
    ; structure with empty value
    [(structV _ name '())
     (string-append "{" (symbol->string name) "}")]
    ; Recursion :
    ; estructura con lista de valores
    [(structV _ name values)
     (string-append "{" (symbol->string name) " "
                    (foldr string-append "" (map pretty-printing values)) "}")]
    ; values within the structure (num, sym, bool, str)
    [id (string-append (to-str id))]
    ; empty list
    ['() ""]))

; pretty-printing-list :: number/boolean/procedure/Struct -> string
; this function extends the pretty-printing function in the list structure case.
(define (pretty-printing-list sV)
  (match sV
    ; list structure (extension)
    [(structV 'List _ values)
     (string-append "{list" (pretty-printing-list-vals values))]
    ; structure with empty value
    [(structV _ name '())
     (string-append "{" (symbol->string name) "}")]
    ; Recursion :
    ; strucutre with a list as values
    [(structV _ name values)
     (string-append "{" (symbol->string name) " "
                    (foldr string-append "" (map pretty-printing values)) "}")]
    ; values within the structure (num, sym, bool, str)
    [id (to-str id)]
    ; empty list
    ['() ""]))

; pretty-printing-list-vals : number/boolean/procedure/Struct -> string
; This function covers the rest of the list 
(define (pretty-printing-list-vals l)
  (match l
    [(list value (structV 'List _ values))
     (string-append " "
                    (pretty-printing-list value)
                    (pretty-printing-list-vals values))]
    [(list) "}"]))

; Definition of Streams
; we create the structure as head and tail
(def stream-data '{datatype Stream {stream hd {lazy tl}}})

;; make-stream :: number/boolean/procedure/String Stream -> Stream
(def make-stream '{define make-stream
                  {fun {hd {lazy tl}}
                       {stream hd tl}}})

; stream-hd :: Stream -> number/boolean/procedura/String
; Returns the head of a stream
(def stream-hd '{define stream-hd
                  {fun {s} {match s
                             {case {stream hd tl} => hd}
                             {case hd => hd}}}})

; stream-tl :: Stream -> Stream
; Returns the tail of a stream
(def stream-tl '{define stream-tl
                  {fun {s} {match s
                             {case {stream hd tl} => tl}}}})

; Stream infinito de 1s
(def ones '{define ones {make-stream 1 ones}})

; stream-take: number Stream -> list
; Returns the firsts n values of the stream
(def stream-take '{define stream-take
                  {fun {n stream}
                       {if {zero? n}
                           {Empty}
                           {Cons {stream-hd stream}
                                 {stream-take {- n 1}
                                              {stream-tl stream}}}}}})

; stream-zipWith : Stream1 Stream2 -> Stream
; zipWith-list function applied to Streams
(def stream-zipWith '{define stream-zipWith
                       {fun {f s1 s2}
                            {make-stream
                             {f {stream-hd s1} {stream-hd s2}}
                             {stream-zipWith f {stream-tl s1} {stream-tl s2}}}}})

; fibs: retorna Stream de fibonacci
; Returns the fibonacci numbers
(def fibs '{define fibs
             {make-stream
              1 {make-stream 1
                             {stream-zipWith {fun {x y} {+ x y}}
                                             fibs
                                             {stream-tl fibs}}}}})


; merge-sort : Stream1 Stream2 -> Stream
; Merges two streams sorted
(def merge-sort '{define merge-sort
                   {fun {s1 s2}
                        {if {< {stream-hd s1} {stream-hd s2}}
                            {make-stream {stream-hd s1}
                                         {merge-sort {stream-tl s1} s2}}
                            {make-stream {stream-hd s2}
                                         {merge-sort {stream-tl s2} s1}}}}})

; stream-lib
(def stream-lib (list stream-data
                      make-stream
                      stream-hd
                      stream-tl
                      stream-take))